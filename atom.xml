<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ZhiLI]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://lizhipower.github.io/"/>
  <updated>2015-05-10T07:41:49.216Z</updated>
  <id>http://lizhipower.github.io/</id>
  
  <author>
    <name><![CDATA[ZhiLI]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[继承]]></title>
    <link href="http://lizhipower.github.io/2015/05/10/js-notes3/"/>
    <id>http://lizhipower.github.io/2015/05/10/js-notes3/</id>
    <published>2015-05-10T04:49:41.000Z</published>
    <updated>2015-05-10T07:41:49.216Z</updated>
    <content type="html"><![CDATA[<h2 id="对象冒充">对象冒充</h2><p>原理：构造函数使用this关键字给所有属性和方法赋值（采用类声明的构造函数方式）。以为构造函数只是一个函数，可以使ClassA的构造函数成为ClassB的方法，然后调用它。ClassB就会收到ClassA的构造函数中定义的属性和方法。这里，其实是把ClassA作为常规函数来建立继承机制，而不是作为构造函数。需要注意的是，所有的新属性和新方法都必须在删除了新方法之后定义，否则，新属性和新方法可能会被继承到的属性和方法覆盖。</p>
<p>并且，对象冒充可以支持多重继承，同样的，如果继承的不同类中存在相同的方法和属性，也会存在前者被后者被覆盖的问题。</p>
<p>随着对象冒充的流行，ECMAScript为Function对象加入了<code>call()</code>和<code>apply()</code>。</p>
<ul>
<li><p><code>call()</code><br><code>call()</code>的第一个参数是obj，说明<code>fun.call(obj,arg1,arg2)</code>的<code>fun()</code>中的this关键字的值是obj，这样就可以将<code>call()</code>和对象冒充结合起来，将对象冒充的中赋值、调用和删除替换掉。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">(sColor, sName)</span> </span>{
    <span class="comment">//this.newMethod = ClassA;</span>
    <span class="comment">//this.newMethod(sColor);</span>
    <span class="comment">//delete this.newMethod;</span>
    ClassA.call(ClassB,sColor);

    <span class="keyword">this</span>.name = sName;
    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span>｛
        <span class="title">console</span>.<span class="title">log</span><span class="params">(this.name)</span>;
    ｝;
}        </span>
</code></pre></li>
<li><p><code>apply()</code><br><code>apply()</code>方法有两个参数，用作this的对象和要传递给函数的参数的数组。</p>
</li>
</ul>
<h2 id="原型链">原型链</h2><p>原理：prototype对象是一个模板，要实例化的对象都是以这个模板为基础，prototype对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span><span class="params">()</span> </span>{
};

ClassA.prototype.color = <span class="string">"red"</span>;

<span class="function"><span class="keyword">function</span> <span class="title">ClassB</span><span class="params">()</span> </span>{
};

**ClassB.prototype = <span class="keyword">new</span> ClassA();**
</code></pre><p>与对象冒充相似，子类的所有属性和方法必须出现在prototype属性被赋值后，因为prototype属性被替换成了新对象。<br>原型链的弊端是不支持多重继承，prototype会被覆盖。</p>
<h2 id="混合方式">混合方式</h2><p>创建类的最好方式是用构造函数方式定义属性，用原型方式定义方法，同样，对于继承，也是用对象冒充继承构造函数属性，用原型链继承函数的方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="对象冒充">对象冒充</h2><p>原理：构造函数使用this关键字给所有属性和方法赋值（采用类声明的构造函数方式）。以为构造函数只是一个函数，可以使ClassA的构造函数成为ClassB的方法，然后调用它。ClassB就会收到ClassA的构造函数中定义的属性和]]>
    </summary>
    
      <category term="js" scheme="http://lizhipower.github.io/tags/js/"/>
    
      <category term="note" scheme="http://lizhipower.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对象基础]]></title>
    <link href="http://lizhipower.github.io/2015/05/08/js-notes2/"/>
    <id>http://lizhipower.github.io/2015/05/08/js-notes2/</id>
    <published>2015-05-08T06:43:38.000Z</published>
    <updated>2015-05-10T07:41:49.232Z</updated>
    <content type="html"><![CDATA[<h2 id="定义">定义</h2><ul>
<li>对象：属性的无序结合，每个属性存放一个原始值、对象或者函数。每个对象由类定义，定义了对象的接口（开发者访问的属性和方法），内部工作（使属性和方法发挥作用的代码）。</li>
<li>实例：程序使用类创建对象时，生成的对象叫做类的实例。每个实例的行为相同，但是实例处理一组独立的数据。创建过程叫做实例化。</li>
<li>ECMA-262类：类是对象的配方。</li>
<li>ECMA-262对象：对象由特性（attribute）构成，特性可以是原始值，也可以是引用值，如果特性存放的是函数，它将被看作对象的方法，否则该特性被看错属性。</li>
<li>引用类型：通常叫作类。在ECMAScript中，不能访问对象的物理表示，只能访问对象的引用。每次创建对象，存储在变量中的都是该对象的引用，而不是对象本身。</li>
</ul>
<pre><code><span class="keyword">var</span> a = {<span class="built_in">c</span>:<span class="number">1</span>, b:<span class="number">2</span>}
<span class="built_in">c</span> = a
<span class="built_in">c</span>.<span class="built_in">c</span>=<span class="number">2</span>
<span class="built_in">c</span>
<span class="type">Object</span> {<span class="built_in">c</span>: <span class="number">2</span>, b: <span class="number">2</span>}
a
<span class="type">Object</span> {<span class="built_in">c</span>: <span class="number">2</span>, b: <span class="number">2</span>}
</code></pre><p>所以在对于对象的操作，比如复制中，会遇到深度复制这样的问题，要确保复制的不是引用。</p>
<h2 id="对象的类型">对象的类型</h2><h3 id="本地对象">本地对象</h3><ul>
<li>Array<br>主要方法有：</li>
</ul>
<ol>
<li><code>join</code>、<code>split</code>、<code>slice</code>、<code>pop</code>、<code>shift</code>、<code>push</code>，Array对象的动作像一个栈，是后进先出的。通过<code>shift</code>、<code>push</code>可以使Array对象有队列一样的动作。</li>
<li><code>sort</code>、<code>reverse</code>与数组项的顺序有关。<code>reverse</code>使数组倒序，<code>sort</code>根据数组项的值升序为他们排序。<code>sort</code>是将所有值转化为字符串，然后根据自负代码比较数组项，可以通过<code>sort（obj,fun(){}）</code>设置排序规则来进行排序。</li>
<li><code>splice</code>用来把数据项插入数组中部，可以用来：删除<code>arr.splice(0,2)</code>、插入<code>arr.splice(2,0,&quot;insertContent&quot;)</code>、替换<code>arr.splice(2,1,&quot;replaceContent&quot;)</code>。</li>
</ol>
<ul>
<li>Date<br>Date类对UTC日期和时间有很强的依赖性，需要考虑时区、夏时令等情况。并且覆盖了<code>valueOf</code>、<code>toString</code>方法。</li>
</ul>
<h3 id="内置对象">内置对象</h3><p>定义：由ECMAScript实现提供的、独立于宿主环境的所有对象，在ECMAScript程序开始执行时出现。ECMA-262定义了两个内置对象，即Global和Math。</p>
<ul>
<li>Global</li>
</ul>
<p>Global实际上根本不存在。Global几个比较重要的方法有<code>encodeURI</code>系列，用来处理URI；<code>eval</code>用来吧参数解释为真正的ECMAScript语句，操作Json时候用到过。<br>另外，<strong>在ECMAScript中不存在独立的函数，所有函数都必须是某个对象的方法</strong>。</p>
<h3 id="宿主对象">宿主对象</h3><p>定义：所有非本地对象都是宿主对象。</p>
<ul>
<li>this<br>this用在对象的方法中，关键字this总是只想调用该方法的对象。通过this可以在任意多个地方重用同一个函数。</li>
</ul>
<h2 id="定义类或对象">定义类或对象</h2><h3 id="工厂方式">工厂方式</h3><pre><code><span class="function"><span class="keyword">function</span> <span class="title">createCar</span><span class="params">()</span> </span>{
    <span class="keyword">var</span> oTempCar = <span class="keyword">new</span> <span class="built_in">Object</span>;
    oTempCar.color = <span class="string">"red"</span>;
    oTempCar.showColor = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)
    };

    <span class="keyword">return</span> oTempCar;
}

<span class="keyword">var</span> oCar1 = createCar();
</code></pre><p>这样可以通过调用函数来创建新对象，但是每个对象都会有一个版本的<code>showColor</code>，因此需要通过原型方式来进行定义类。</p>
<h3 id="构造函数方式">构造函数方式</h3><pre><code><span class="function"><span class="keyword">function</span> <span class="title">Car</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.color = <span class="string">"red"</span>;
    <span class="keyword">this</span>.showColor = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)
    };

}

<span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car();
</code></pre><p>同样地，也会重复生成函数。</p>
<h3 id="原型方式">原型方式</h3><pre><code><span class="function"><span class="keyword">function</span> <span class="title">Car</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.prototype.color = <span class="string">"red"</span>;
    <span class="keyword">this</span>.prototype.showColor = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
        <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)
    };

}

<span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car();
</code></pre><p>在调用<code>new Car()</code>时，原型的所有属性都被赋予也要创建的对象，也就是说所有的Car实例存放的都是指向<code>showColor（）</code>的指针。然而，由于都是指向同一个位置，如果改变某个实例的属性，其他所有实例的该属性都会改变。因此需要混合构造函数/原型方式来进行创建对象。</p>
<h3 id="混合方式">混合方式</h3><pre><code><span class="function"><span class="keyword">function</span> <span class="title">Car</span><span class="params">()</span> </span>{
    <span class="keyword">this</span>.color = <span class="string">"red"</span>;
}
Car.prototype.showColor = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)
};
</code></pre><h2 id="对象修改">对象修改</h2><p>通过<code>prototype</code>可以创建新方法，重新定义已有方法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="定义">定义</h2><ul>
<li>对象：属性的无序结合，每个属性存放一个原始值、对象或者函数。每个对象由类定义，定义了对象的接口（开发者访问的属性和方法），内部工作（使属性和方法发挥作用的代码）。</li>
<li>实例：程序使用类创建对象时，生成的对象叫做]]>
    </summary>
    
      <category term="js" scheme="http://lizhipower.github.io/tags/js/"/>
    
      <category term="note" scheme="http://lizhipower.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[四月总结]]></title>
    <link href="http://lizhipower.github.io/2015/05/05/april-review/"/>
    <id>http://lizhipower.github.io/2015/05/05/april-review/</id>
    <published>2015-05-05T13:43:02.000Z</published>
    <updated>2015-05-05T14:18:06.136Z</updated>
    <content type="html"><![CDATA[<h2 id="代码">代码</h2><p>写了半天终于把task3功能全部写完，三个功能下来确实发现基础变的好很多，不再依赖其他外部的东西，很多东西理解还是不深入，继续读代码吧。<br>matlab上面关于配电网重构和台风预警的结合部分迟迟没有动笔，大约这个礼拜开始尝试着把配电网的地理位置坐标做出来吧。</p>
<h2 id="论文">论文</h2><p>终于写完了第一篇，交给老板看，看完这周末一定投出去。刚才写到这里为了杀死拖延症花了半个小时终于把论文的标题，作者信息等等全部写好发给了老板。</p>
<h2 id="生活">生活</h2><p>该踢球踢球，该锻炼锻炼，媳妇儿终于回大陆了，结束我一年支教，她一年留学的异地，开始一段新的她在家我在学校的异地。</p>
<h2 id="感想">感想</h2><p>四月很忙，不过好的事情是终于知道自己想要什么，自己对于科研也有了一定的想法，有了自己的一点理解，在代码方面也算是一点点的入门了。记住那句话：<strong>跳出算法，回归物理意义。</strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="代码">代码</h2><p>写了半天终于把task3功能全部写完，三个功能下来确实发现基础变的好很多，不再依赖其他外部的东西，很多东西理解还是不深入，继续读代码吧。<br>matlab上面关于配电网重构和台风预警的结合部分迟迟没有动笔，大约这个礼拜开始尝试着把配电]]>
    </summary>
    
      <category term="日记" scheme="http://lizhipower.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[distribution-network-reconfiguraton-with-HSA]]></title>
    <link href="http://lizhipower.github.io/2015/04/25/distribution-network-reconfiguraton-with-HSA/"/>
    <id>http://lizhipower.github.io/2015/04/25/distribution-network-reconfiguraton-with-HSA/</id>
    <published>2015-04-25T14:22:36.000Z</published>
    <updated>2015-04-25T14:34:23.927Z</updated>
    <content type="html"><![CDATA[<h2 id="HSA">HSA</h2><p>目前和声算法已经做得比较成熟，小系统和中系统都可以算</p>
<h2 id="powerflow">powerflow</h2><p>潮流主要用了牛拉法，对于牛拉的核心掌握还不是很好，但是牛拉算潮流基本上封装的比较好，在33-bus和69-bus上都验证了有效性。<br>但是在119-bus上结果不对，而且119-bus系统编号有问题，找了一个没问题的算例，结果更奇葩，不能理解。</p>
<h2 id="sample_system">sample system</h2><p>支持33-bus，69-bus；不支持119-bus。前者都是11.26kV，后者是11kV。</p>
<h2 id="TODO">TODO</h2><ol>
<li>台风模型：<ul>
<li>台风的影响半径：一般十级100km，也有300km</li>
<li>台风对配网的影响：故障率建模</li>
<li>台风影响范围：确定受影响最严重的台风</li>
</ul>
</li>
<li>论文：<ul>
<li>月底或5月初投电网</li>
<li>5月中完成台风模型</li>
</ul>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="HSA">HSA</h2><p>目前和声算法已经做得比较成熟，小系统和中系统都可以算</p>
<h2 id="powerflow">powerflow</h2><p>潮流主要用了牛拉法，对于牛拉的核心掌握还不是很好，但是牛拉算潮流基本上封装的比较好，在33-bus]]>
    </summary>
    
      <category term="电力" scheme="http://lizhipower.github.io/tags/%E7%94%B5%E5%8A%9B/"/>
    
      <category term="算法" scheme="http://lizhipower.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="配电网" scheme="http://lizhipower.github.io/tags/%E9%85%8D%E7%94%B5%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ECMAScript基础]]></title>
    <link href="http://lizhipower.github.io/2015/04/23/js-notes/"/>
    <id>http://lizhipower.github.io/2015/04/23/js-notes/</id>
    <published>2015-04-23T07:50:21.000Z</published>
    <updated>2015-04-23T13:26:30.682Z</updated>
    <content type="html"><![CDATA[<h1 id="ECMAScript基础">ECMAScript基础</h1><h2 id="原始类型">原始类型</h2><ol>
<li>原始类型有Undefined、Null、Bollean、Number和String。</li>
<li>typeof用来判断一个值是否在某种类型的范围内，引用类型或者Null返回object，null被认为是对象的占位符。</li>
<li>undefined： <ul>
<li>声明的对象未初始化</li>
<li>对象未定义：<strong>只能对未定义的对象使用typeof，使用其他运算符会报错</strong></li>
<li>函数无明确返回值</li>
</ul>
</li>
<li>null用于表示尚未存在的对象。</li>
<li><code>typeof(1)</code>和<code>typeof(NaN)</code>都是<code>number</code>，但<code>isNaN(NaN)</code>与<code>isNaN(1)</code>是不一样的。</li>
<li>Number的<code>toString()</code>可以根据不同的基输出结果。</li>
<li>String的<code>pasreInt()</code> 可以把字符串中的第一串数字字符转化成数字（0xA会被转化成10），会在第一个无效字符之前停止，同样也有基模式。</li>
</ol>
<h2 id="引用类型">引用类型</h2><ol>
<li>String可以有<code>indexof()</code>、<code>charAt()</code>、<code>valueOf()</code>、<code>toString()</code>等方法。</li>
<li>String的<code>slice()</code>可以传负参数，其表示字符串长度加上负参数值，slice开始位置包含在返回值，终止位置不包含在返回值，从0开始计位置。</li>
</ol>
<h2 id="函数">函数</h2><ol>
<li>js的函数不支持重载，但是可以使用特殊对象arguments，无需指出参数名，就能访问它们。ECMAScript不会验证传递给函数的参数个数是否等于函数定义的参数个数，其中，遗漏的函数以undefined传递给函数，多余的参数被忽略，因此可以通过arguments来简易模拟函数重载。<br><code>function a() {}</code>等价于<code>var a = function(){}</code>。</li>
<li>函数实际上是功能完整的对象。Function类可以表示开发者定义的任何函数。<strong>函数名实际上是函数对象的引用值</strong>，<strong>函数可以作为参数传递给另外一个函数</strong>。</li>
<li><p><strong>闭包</strong></p>
<p><strong>闭包</strong>是指函数能使用函数外定义的变量。</p>
</li>
</ol>
<pre><code>&lt;!--lang:javascript--&gt; 
<span class="keyword">var</span> iBaseNum = <span class="number">10</span>;
<span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span><span class="params">(iNum1, iNum2)</span> </span>{
    <span class="comment">//闭包</span>
    <span class="function"><span class="keyword">function</span> <span class="title">doAddition</span> <span class="params">()</span></span>{
        <span class="keyword">return</span> iNum1 + iNum2 + iBaseNum;
    }
<span class="keyword">return</span> doAddition();
} 
</code></pre><p> 闭包可以用来读取局部变量。</p>
<pre><code>function f1(){
    <span class="keyword">var</span> n=<span class="number">999</span>;
    function f2(){
       alert(n); // <span class="number">999</span>
    }
}

function f1(){
    <span class="keyword">var</span> n=<span class="number">999</span>;
    function f2(){
        alert(n); 
    }
    <span class="keyword">return</span> f2;//返回函数的引用
}
<span class="keyword">var</span> <span class="literal">result</span>=f1();// <span class="literal">result</span> =  f2
<span class="literal">result</span>(); // <span class="number">999</span>
</code></pre><p> <a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" title="学习Javascript闭包" target="_blank" rel="external">闭包</a>主要用来<strong>读取函数内部的变量</strong>或者<strong>让这些变量的值始终保持在内存中</strong>。个人认为，闭包的关键在于返回了一个子函数，子函数可以调用父函数的变量，从而可以再外部调用到父函数内部的变量。这里的子函数如果是定义为全局变量，则直接通过调用子函数来实现访问内部变量。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ECMAScript基础">ECMAScript基础</h1><h2 id="原始类型">原始类型</h2><ol>
<li>原始类型有Undefined、Null、Bollean、Number和String。</li>
<li>typeof用来判断一个值是否在某]]>
    </summary>
    
      <category term="js" scheme="http://lizhipower.github.io/tags/js/"/>
    
      <category term="note" scheme="http://lizhipower.github.io/tags/note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015-04-23]]></title>
    <link href="http://lizhipower.github.io/2015/04/23/2015-04-23/"/>
    <id>http://lizhipower.github.io/2015/04/23/2015-04-23/</id>
    <published>2015-04-23T06:37:15.000Z</published>
    <updated>2015-04-23T06:57:38.476Z</updated>
    <content type="html"><![CDATA[<h1 id="最近主要在做三件事">最近主要在做三件事</h1><ul>
<li>百度IFE</li>
</ul>
<p><a href="https://github.com/baidu-ife/ife" target="_blank" rel="external">https://github.com/baidu-ife/ife</a></p>
<ul>
<li>宁波RDS</li>
</ul>
<p>下周甲方过来汇报</p>
<ul>
<li>配网论文</li>
</ul>
<p>月底提交，打算投电网吧，希望能在这学期搞定第一篇EI。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="最近主要在做三件事">最近主要在做三件事</h1><ul>
<li>百度IFE</li>
</ul>
<p><a href="https://github.com/baidu-ife/ife" target="_blank" rel="external">http]]>
    </summary>
    
      <category term="日记" scheme="http://lizhipower.github.io/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>